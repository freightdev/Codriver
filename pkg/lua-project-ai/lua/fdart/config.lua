-- fdart/lua/fdart/config.lua
-- Configuration management with YAML/JSON support

local lfs = require("lfs")
local M = {}

-- Default configuration
M.defaults = {
  -- General settings
  project_root = nil,
  lib_dir = "lib",
  deep_scan = true,
  backup = true,
  dry_run = false,
  verbose = false,
  quiet = false,
  log_level = "info",
  
  -- File patterns
  include_patterns = {"%.dart$"},
  exclude_patterns = {"%.g%.dart$", "%.freezed%.dart$", "%.mocks%.dart$"},
  exclude_dirs = {"%.git", "%.dart_tool", "build", "%.idea", "android", "ios", "web", "linux", "macos", "windows", "test"},
  
  -- Analysis settings
  max_file_size = 500, -- lines
  max_fix_iterations = 5,
  auto_pubget = true,
  auto_format = true,
  
  -- Barrel settings
  barrel_filename = "index.dart",
  auto_barrel = true,
  barrel_header = "// Auto-generated barrel file\n// Generated by fdart\n",
  
  -- AI/Ollama settings
  ollama = {
    enabled = false,
    host = "localhost",
    port = 11434,
    model = "codellama:13b",
    timeout = 300,
    max_context_lines = 100,
    allow_command_execution = false, -- Security: disabled by default
    allowed_commands = {
      "fdart", "flutter", "dart", "git", "tree", "cat", "grep", "find"
    },
    system_prompt = [[You are an expert Flutter/Dart developer assistant. 
You help fix code issues, suggest improvements, and can execute safe commands.
Always explain your reasoning and be precise with code suggestions.]]
  },
  
  -- Import organization
  import_order = {"dart:", "package:flutter/", "package:", "relative"},
  
  -- Cache settings
  use_cache = true,
  cache_file = ".fdart_cache.json",
  cache_ttl = 3600, -- 1 hour
  
  -- Output settings
  output_format = "pretty", -- pretty, json, minimal
  color = true,
  icons = true,
}

M.config = {}
M.config_files = {".fdart.yaml", ".fdart.yml", ".fdart.json", "fdart.config.lua"}

-- Load configuration from file
function M.load(path)
  -- Start with defaults
  M.config = M.deep_copy(M.defaults)
  
  -- Find config file
  local config_path = path
  if not config_path then
    config_path = M.find_config_file()
  end
  
  if config_path then
    local ext = config_path:match("%.([^.]+)$")
    if ext == "lua" then
      M.load_lua_config(config_path)
    elseif ext == "json" then
      M.load_json_config(config_path)
    elseif ext == "yaml" or ext == "yml" then
      M.load_yaml_config(config_path)
    end
  end
  
  return true
end

-- Find config file in current or parent directories
function M.find_config_file()
  local current = lfs.currentdir()
  
  for i = 1, 10 do
    for _, filename in ipairs(M.config_files) do
      local path = current .. "/" .. filename
      local f = io.open(path, "r")
      if f then
        f:close()
        return path
      end
    end
    
    local parent = current:match("(.+)/[^/]+$")
    if not parent or parent == current then break end
    current = parent
  end
  
  return nil
end

-- Load Lua config
function M.load_lua_config(path)
  local chunk, err = loadfile(path)
  if not chunk then
    return false, "Failed to load config: " .. err
  end
  
  local user_config = chunk()
  M.merge(M.config, user_config)
  return true
end

-- Load JSON config
function M.load_json_config(path)
  local json_ok, json = pcall(require, "dkjson")
  if not json_ok then
    json_ok, json = pcall(require, "cjson")
  end
  
  if not json_ok then
    return false, "JSON library not available"
  end
  
  local f = io.open(path, "r")
  if not f then return false, "Cannot open file" end
  
  local content = f:read("*all")
  f:close()
  
  local user_config, err = json.decode(content)
  if not user_config then
    return false, "Invalid JSON: " .. err
  end
  
  M.merge(M.config, user_config)
  return true
end

-- Load YAML config (basic parser)
function M.load_yaml_config(path)
  local f = io.open(path, "r")
  if not f then return false, "Cannot open file" end
  
  local content = f:read("*all")
  f:close()
  
  local user_config = M.parse_yaml_simple(content)
  M.merge(M.config, user_config)
  return true
end

-- Simple YAML parser (handles basic key: value pairs)
function M.parse_yaml_simple(content)
  local config = {}
  local current_section = config
  local section_stack = {}
  
  for line in content:gmatch("[^\r\n]+") do
    -- Skip comments and empty lines
    if not line:match("^%s*#") and not line:match("^%s*$") then
      local indent = #line:match("^%s*")
      local key, value = line:match("^%s*([%w_]+):%s*(.*)$")
      
      if key then
        -- Handle nested sections
        if value == "" then
          local new_section = {}
          current_section[key] = new_section
          table.insert(section_stack, {section = current_section, indent = indent})
          current_section = new_section
        else
          -- Parse value
          if value == "true" then value = true
          elseif value == "false" then value = false
          elseif tonumber(value) then value = tonumber(value)
          elseif value:match("^['\"](.+)['\"]$") then
            value = value:match("^['\"](.+)['\"]$")
          end
          current_section[key] = value
        end
      end
      
      -- Handle going back up in nesting
      while #section_stack > 0 and indent <= section_stack[#section_stack].indent then
        current_section = table.remove(section_stack).section
      end
    end
  end
  
  return config
end

-- Deep copy table
function M.deep_copy(obj)
  if type(obj) ~= 'table' then return obj end
  local copy = {}
  for k, v in pairs(obj) do
    copy[k] = M.deep_copy(v)
  end
  return copy
end

-- Merge user config into base config
function M.merge(base, user)
  for k, v in pairs(user) do
    if type(v) == "table" and type(base[k]) == "table" then
      M.merge(base[k], v)
    else
      base[k] = v
    end
  end
end

-- Get config value
function M.get(key, default)
  local keys = {}
  for k in key:gmatch("[^.]+") do
    table.insert(keys, k)
  end
  
  local value = M.config
  for _, k in ipairs(keys) do
    if type(value) ~= "table" then return default end
    value = value[k]
    if value == nil then return default end
  end
  
  return value
end

-- Set config value
function M.set(key, value)
  local keys = {}
  for k in key:gmatch("[^.]+") do
    table.insert(keys, k)
  end
  
  local target = M.config
  for i = 1, #keys - 1 do
    if type(target[keys[i]]) ~= "table" then
      target[keys[i]] = {}
    end
    target = target[keys[i]]
  end
  
  target[keys[#keys]] = value
end

-- Save config to file
function M.save(path)
  path = path or M.find_config_file() or ".fdart.json"
  
  local ext = path:match("%.([^.]+)$")
  if ext == "json" then
    return M.save_json_config(path)
  end
  
  return false, "Only JSON format supported for saving"
end

-- Save as JSON
function M.save_json_config(path)
  local json_ok, json = pcall(require, "dkjson")
  if not json_ok then
    json_ok, json = pcall(require, "cjson")
  end
  
  if not json_ok then
    return false, "JSON library not available"
  end
  
  local f = io.open(path, "w")
  if not f then return false, "Cannot write file" end
  
  local content = json.encode(M.config, {indent = true})
  f:write(content)
  f:close()
  
  return true
end

-- Initialize config with custom values
function M.init(custom)
  M.config = M.deep_copy(M.defaults)
  if custom then
    M.merge(M.config, custom)
  end
end

return M